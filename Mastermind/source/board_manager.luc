/*
 * This module is used to manage the board state for both the user entry and feedback entry.
 * This module is connected to display_manager to display all the entry in LED.
 */
module board_manager (
    input clk,                   // clock
    input rst,                   // reset
    input start[1],              // Flag for starting the game(read signal from the random_generator)
    input ending[2],                // Flag for determine the game result
    input chk_done[1],               // Flag for done checking the user entry
    input ans[16],               // Random generated answer from the random_generator 
    input new_row[16],           // User input
    input feedback[16],    // Checker result
    output ans_ref[16],          // Pass the stored answer to the checker
    output board_out[8][4][4],     // Board state
    output feedback_out[8][4][4],  // Feedback state
    output current_idx[3]
  ) {

  // Define all the constant //
  const CONTINUE = 2b00;
  const WIN = 2b10;
  const LOSS = 2b11;
  // End of constant definition //

  .clk(clk) {
    .rst(rst) {
      dff row_idx[3];                  // Store the current row index
      dff board[8][4][4];              // Store the current state of the user input
      dff feedback_storage[8][4][4];   // Store the checking result
      dff ans_storage[16];             // Store the answer generated by the random_generator
      dff winboard[8][4][4];           // Store the winning board state (ALL GREEN)
      dff lossboard[8][4][4];          // Store the lossing board state (ALL answer)
      fsm state = {INIT, PLAY, FEEDBACK, WIN, LOSS};

    } 
  }
  always {
    // Connect all the output //
    ans_ref = ans_storage.q;
    board_out = board.q;
    feedback_out = feedback_storage.q;
    current_idx = row_idx.q;
    // End of output connections //

    // Save the user entry and checking result // 
    board.d[row_idx.q] = c{{new_row[3:0], new_row[7:4], new_row[11:8], new_row[15:12]}};
    feedback_storage.d[row_idx.q] = c{{feedback[3:0], feedback[7:4], feedback[11:8], feedback[15:12]}};
    // End of saving the user entry and checking result //
    case (state.q) {
        state.INIT:
        if (start) {  // When the random_generator data is ready
          state.d = state.PLAY;
          ans_storage.d = ans;           // Save the answer to the storage
          winboard.d = 8x{{4x{{4b0}}}};  // All GREEN
          lossboard.d = 8x{{c{{ans[3:0]}, {ans[7:4]}, {ans[11:8]}, {ans[15:12]}}}};  // All answer
          board.d = 8x{{4x{{4b1111}}}};  // Set the user input to all black(LED off)
          feedback_storage.d = 8x{{4x{{4b1111}}}};  // Set the checking result to all black(LED off)
        }
      state.PLAY:
        if (chk_done) {  // When the checker done checking      
          state.d = state.FEEDBACK;
        }
      state.FEEDBACK:
        if (ending == WIN) {
          state.d = state.WIN;
        } else if (ending == LOSS) {
          state.d = state.LOSS;
        } else if (ending == CONTINUE) {
          row_idx.d = row_idx.q + 1;
        }
      state.WIN:
        board.d = winboard.q;  // Output the winboard
      state.LOSS:
        board.d = lossboard.q; // Output the lossboard
    }
  }
}
