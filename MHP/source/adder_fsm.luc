module adder_fsm (
    input clk,           // clock
    input rst,           // reset
    input a[1],             // input A
    input b[1],             // input B
    input c[1],
    input expect[2],
    input raw[2],         // SUM of the full adder
    output pass[2],    // result of FSM: 1 for PASS, 0 for FAIL
    output input_ref[3],
    output ans_ref[2],
    output err_ref[2]
  ) {
  .clk(clk) {
    .rst(rst) {
      fsm state = {IDLE, S, C, CS, FAIL};
    }
  }
  
  checker checker;
  const PASS = 2b01;
  const FAIL = 2b00;

  always {
    
    checker.expect = expect;
    checker.raw = raw;
    
    input_ref = c{c, b, a};    
    ans_ref = expect;
    err_ref = raw;

    pass = PASS;

    case (state.q) {
      state.IDLE:
        if (rst)
          state.d = state.IDLE;
        if ((a + b + c) == 3)
          state.d = state.CS;
        if ((a + b + c) == 2)
          state.d = state.C;
        if ((a + b + c) == 1)
          state.d = state.S;
        if ((a + b + c) == 0)
          // Check the Sum and Cout
          if (~checker.pass)
            state.d = state.FAIL;        

      state.S:
        if (rst)
          state.d = state.IDLE;
        if ((a + b + c) == 3)
          state.d = state.CS;
        if ((a + b + c) == 2)
          state.d = state.C;
        if ((a + b + c) == 1)
          // Check the Sum and Cout
          if (~checker.pass)
            state.d = state.FAIL;       
        if ((a + b + c) == 0)
          state.d = state.IDLE;
        
      state.C:
        if (rst)
          state.d = state.IDLE;
        if ((a + b + c) == 3)
          state.d = state.CS;
        if ((a + b + c) == 2)
          // Check the Sum and Cout
          if (~checker.pass)
            state.d = state.FAIL;
        if ((a + b + c) == 1)
          state.d = state.S;
        if ((a + b + c) == 0)
          state.d = state.IDLE;
        
      state.CS:
        if (rst)
          state.d = state.IDLE;
        if ((a + b + c) == 3)
          // Check the Sum and Cout
          if (~checker.pass)
            state.d = state.FAIL;
        if ((a + b + c) == 2)
          state.d = state.C;
        if ((a + b + c) == 1)
          state.d = state.S;
        if ((a + b + c) == 0)
          state.d = state.IDLE;

      state.FAIL:
        pass = FAIL;
        if (rst) {
          state.d = state.IDLE;
        }        
    }  
  }
}
