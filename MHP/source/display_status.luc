module display_status #(
    CHARS = 4 : CHARS > 0, // set the no. of characters
    DIV = 16 : DIV >= 0    // control the switching speed of characters
  )(
    input clk,             // clock
    input rst,             // reset
    input mode[1],         // 1 for auto, 0 for manual
    input status[2],       // 1 for pass, 0 for fail(mode: 0)
                           // 2 for idle, 1 for sum, 0 for ci_o(mode: 1)
    output seg [7],        // LED segments
    output sel [CHARS]     // character selected
  ) {
  
  // number of bits required to store CHARS-1
  const CHARS_BITS = $clog2(CHARS);
  
  
  // iterate from 0 to CHARS-1 to diplay each character
  .clk(clk), .rst(rst) {
    counter ctr (#DIV(DIV), #SIZE(CHARS_BITS), #TOP(CHARS-1), #UP(1)); 
  }

  fail_str fail_dec;    // fail decoder 
  pass_str pass_dec;    // pass decoder
  sum_str sum_dec;      // sum decoder
  ci_o ci_o_dec;        // ci_o decoder
  idle_str idle_dec;    // idle decoder    
  decoder digit_dec (#WIDTH(CHARS_BITS));   // digit decoder
  
  always {

    // Set empty input for fail_dec and pass_dec
    fail_dec.char = 2b00;
    pass_dec.char = 2b00;
    sum_dec.char = 2b00;
    ci_o_dec.char = 2b00;
    idle_dec.char = 2b00;

    if (mode) {
      if (status == 2b01) {
        pass_dec.char = ctr.value;
        seg = pass_dec.segs;
      }
      else {
        fail_dec.char = ctr.value;
        seg = fail_dec.segs;
      }
    }
    else {
      if (status == 2b10) {
        idle_dec.char = ctr.value;
        seg = idle_dec.segs;
      }
      if (status == 2b01) {
        sum_dec.char = ctr.value;
        seg = sum_dec.segs;
      }
      if (status == 2b00){
        ci_o_dec.char = ctr.value;
        seg = ci_o_dec.segs; 
      }   
    }

    digit_dec.in = ctr.value;
    sel = digit_dec.out;
  }
}
